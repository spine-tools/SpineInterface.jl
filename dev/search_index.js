var documenterSearchIndex = {"docs":
[{"location":"tutorials/tutorial_spine_database/#Tutorial-spine-database","page":"Tutorial spine database","title":"Tutorial spine database","text":"","category":"section"},{"location":"tutorials/tutorial_spine_database/","page":"Tutorial spine database","title":"Tutorial spine database","text":"Once SpineInterface is installed, we can start using it in Julia scripts or consoles.","category":"page"},{"location":"tutorials/tutorial_spine_database/","page":"Tutorial spine database","title":"Tutorial spine database","text":"julia> using SpineInterface","category":"page"},{"location":"tutorials/tutorial_spine_database/","page":"Tutorial spine database","title":"Tutorial spine database","text":"We can immediately start to add objects to a non-existing database because the database will automatically be created. That does imply that small writing mistakes result in new databases. To avoid writing mistakes it is recommended to make a variable that refers to the url.","category":"page"},{"location":"tutorials/tutorial_spine_database/","page":"Tutorial spine database","title":"Tutorial spine database","text":"note: Note\nThe recomended way of creating, populating, and maintaining Spine databases is through  Spine Toolbox.","category":"page"},{"location":"tutorials/tutorial_spine_database/","page":"Tutorial spine database","title":"Tutorial spine database","text":"julia> url = \"sqlite:///$(@__DIR__)/quick_start.sqlite\"\n\njulia> commit_message=\"initial commit message for the new database with the objects actor and film\"\n\njulia> import_data(url, commit_message; object_classes=[\"actor\", \"film\"])","category":"page"},{"location":"tutorials/tutorial_spine_database/","page":"Tutorial spine database","title":"Tutorial spine database","text":"The above will create a SQLite file called quick_start.sqlite in the present working directory, with the Spine database schema and commits the specified changes to the database (the process uses a git workflow) The content consists of two object classes called \"actor\" and \"film\".","category":"page"},{"location":"tutorials/tutorial_spine_database/","page":"Tutorial spine database","title":"Tutorial spine database","text":"To generate convenience functions for that database, you can call using_spinedb.","category":"page"},{"location":"tutorials/tutorial_spine_database/","page":"Tutorial spine database","title":"Tutorial spine database","text":"note: Note\nNote that using_spinedb may require the Julia package PyCall to function properly.","category":"page"},{"location":"tutorials/tutorial_spine_database/","page":"Tutorial spine database","title":"Tutorial spine database","text":"julia> using_spinedb(url)\n\njulia> actor()\n0-element Array{Union{Int64, T} where T<:SpineInterface.AbstractObject,1}\n\njulia> film()\n0-element Array{Union{Int64, T} where T<:SpineInterface.AbstractObject,1}\n","category":"page"},{"location":"tutorials/tutorial_spine_database/","page":"Tutorial spine database","title":"Tutorial spine database","text":"As you can see, both actor() and film() return 0-element Arrays. That's because none of these classes has any objects yet. Let's see what happens if we add some.","category":"page"},{"location":"tutorials/tutorial_spine_database/","page":"Tutorial spine database","title":"Tutorial spine database","text":"julia> object_list = [\n\t[\"actor\", \"Phoenix\"], \n\t[\"actor\", \"Johansson\"], \n\t[\"film\", \"Her\"], \n\t[\"film\", \"Joker\"]\n];\n\njulia> import_data(url, \"add objects\"; objects=object_list)\n\njulia> using_spinedb(url)\n\njulia> actor()\n2-element Array{Union{Int64, T} where T<:SpineInterface.AbstractObject,1}:\n Phoenix\n Johansson\n\njulia> film()\n2-element Array{Union{Int64, T} where T<:SpineInterface.AbstractObject,1}:\n Her\n Joker\n\njulia> film(:Her)\nHer\n\njulia> typeof(ans)\nObject\n","category":"page"},{"location":"tutorials/tutorial_spine_database/","page":"Tutorial spine database","title":"Tutorial spine database","text":"Things got a little bit more interesting.","category":"page"},{"location":"tutorials/tutorial_spine_database/","page":"Tutorial spine database","title":"Tutorial spine database","text":"Now let's see what happens if we add some relationships to the database:","category":"page"},{"location":"tutorials/tutorial_spine_database/","page":"Tutorial spine database","title":"Tutorial spine database","text":"julia> relationship_class_list = [[\"actor__film\", [\"actor\", \"film\"]]];\n\njulia> relationship_list = [\n\t[\"actor__film\", [\"Phoenix\", \"Joker\"]], \n\t[\"actor__film\", [\"Phoenix\", \"Her\"]], \n\t[\"actor__film\", [\"Johansson\", \"Her\"]]\n];\n\njulia> import_data(\n\turl, \"add relationships\"; relationship_classes=relationship_class_list, relationships=relationship_list\n)\n","category":"page"},{"location":"tutorials/tutorial_spine_database/","page":"Tutorial spine database","title":"Tutorial spine database","text":"The above will add a relationship class called \"actor__film\"  between the \"actor\" and \"film\" object classes, and a couple of relationships of that class. Now let's see the effect of calling using_spinedb:","category":"page"},{"location":"tutorials/tutorial_spine_database/","page":"Tutorial spine database","title":"Tutorial spine database","text":"julia> using_spinedb(url)\n\njulia> actor__film()\n3-element Array{NamedTuple{K,V} where V<:Tuple{Vararg{Union{Int64, T} where T<:SpineInterface.AbstractObject,N} where N} where K,1}:\n (actor = Phoenix, film = Her)\n (actor = Johansson, film = Her)\n (actor = Phoenix, film = Joker)\n\njulia> actor__film(actor=actor(:Johansson))\n1-element Array{Object,1}:\n Her\n\njulia> actor__film(film=film(:Her))\n2-element Array{Object,1}:\n Johansson\n Phoenix\n","category":"page"},{"location":"tutorials/tutorial_spine_database/","page":"Tutorial spine database","title":"Tutorial spine database","text":"Finally, let's add some parameters and some values to the database:","category":"page"},{"location":"tutorials/tutorial_spine_database/","page":"Tutorial spine database","title":"Tutorial spine database","text":"julia> object_parameter_list = [[\"film\", \"release_year\"]];\n\njulia> relationship_parameter_list = [[\"actor__film\", \"character_name\"]];\n\njulia> object_parameter_value_list = [\n\t[\"film\", \"Joker\", \"release_year\", 2019],\n\t[\"film\", \"Her\", \"release_year\", 2013],\n];\n\njulia> relationship_parameter_value_list = [\n\t[\"actor__film\", [\"Phoenix\", \"Joker\"], \"character_name\", \"Arthur\"], \n\t[\"actor__film\", [\"Phoenix\", \"Her\"], \"character_name\", \"Theodore\"], \n\t[\"actor__film\", [\"Johansson\", \"Her\"], \"character_name\", \"Samantha\"]\n];\n\njulia> import_data(\n\turl,\n    \"add parameters\";\n\tobject_parameters=object_parameter_list, \n\trelationship_parameters=relationship_parameter_list, \n\tobject_parameter_values=object_parameter_value_list,\n\trelationship_parameter_values=relationship_parameter_value_list\n)\n","category":"page"},{"location":"tutorials/tutorial_spine_database/","page":"Tutorial spine database","title":"Tutorial spine database","text":"And after calling using_spinedb:","category":"page"},{"location":"tutorials/tutorial_spine_database/","page":"Tutorial spine database","title":"Tutorial spine database","text":"julia> using_spinedb(url)\n\njulia> release_year(film=film(:Joker))\n2019\n\njulia> release_year(film=film(:Her))\n2013\n\njulia> character_name(film=film(:Joker), actor=actor(:Phoenix))\n:Arthur\n\njulia> character_name(actor=actor(:Johansson), film=film(:Her))\n:Samantha\n\njulia> character_name(actor=actor(:Johansson), film=film(:Joker))\nERROR: parameter character_name is not specified for argument(s) :actor => Johansson:film => Joker\n","category":"page"},{"location":"tutorials/tutorial_spine_database/","page":"Tutorial spine database","title":"Tutorial spine database","text":"The full script can be found in the examples folder.","category":"page"},{"location":"library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Documentation for SpineInterface.jl.","category":"page"},{"location":"library/#Contents","page":"Library","title":"Contents","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages = [\"library.md\"]\nDepth = 3","category":"page"},{"location":"library/#Index","page":"Library","title":"Index","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"","category":"page"},{"location":"library/#Types","page":"Library","title":"Types","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"ObjectClass\nObject\nRelationshipClass\nParameter\nTimeSlice\nTimeSeries\nMap\nAnything","category":"page"},{"location":"library/#SpineInterface.ObjectClass","page":"Library","title":"SpineInterface.ObjectClass","text":"ObjectClass\n\nA type for representing an object class from a Spine db.\n\n\n\n\n\n","category":"type"},{"location":"library/#SpineInterface.Object","page":"Library","title":"SpineInterface.Object","text":"Object\n\nA type for representing an object from a Spine db; an instance of an object class.\n\n\n\n\n\n","category":"type"},{"location":"library/#SpineInterface.RelationshipClass","page":"Library","title":"SpineInterface.RelationshipClass","text":"RelationshipClass\n\nA type for representing a relationship class from a Spine db.\n\n\n\n\n\n","category":"type"},{"location":"library/#SpineInterface.Parameter","page":"Library","title":"SpineInterface.Parameter","text":"Parameter\n\nA type for representing a parameter related to an object class or a relationship class in a Spine db.\n\n\n\n\n\n","category":"type"},{"location":"library/#SpineInterface.TimeSlice","page":"Library","title":"SpineInterface.TimeSlice","text":"TimeSlice\n\nA type for representing a slice of time.\n\n\n\n\n\n","category":"type"},{"location":"library/#SpineInterface.TimeSeries","page":"Library","title":"SpineInterface.TimeSeries","text":"TimeSeries\n\nA type for representing a series of values in a Spine db. The index is a DateTime.\n\n\n\n\n\n","category":"type"},{"location":"library/#SpineInterface.Map","page":"Library","title":"SpineInterface.Map","text":"Map{K,V}\n\nA nested general purpose indexed value corresponding to the similarly named spinedb_api class.\n\nConsists of an Array of indexes and an Array of values.\n\n\n\n\n\n","category":"type"},{"location":"library/#SpineInterface.Anything","page":"Library","title":"SpineInterface.Anything","text":"Anything\n\nA type with no fields that is the type of anything.\n\n\n\n\n\n","category":"type"},{"location":"library/#Functions","page":"Library","title":"Functions","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"using_spinedb(::String)\nimport_data(url::String, data::Union{ObjectClass,RelationshipClass}, comment::String; upgrade=false)\nObjectClass()\nRelationshipClass()\nParameter()\nindices(::Parameter)\nTimeSlice(::DateTime, ::DateTime)\nduration(::TimeSlice)\nbefore(::TimeSlice, ::TimeSlice)\niscontained(::TimeSlice, ::TimeSlice)\noverlaps(::TimeSlice, ::TimeSlice)\noverlap_duration(::TimeSlice, ::TimeSlice)\nt_lowest_resolution(::Array{TimeSlice,1})\nt_highest_resolution(::Array{TimeSlice,1})\nwrite_parameters(parameters::Dict, url::String; upgrade=true, for_object=true, report=\"\", alternative=\"\", on_conflict=\"merge\", comment=\"\")","category":"page"},{"location":"library/#SpineInterface.using_spinedb-Tuple{String}","page":"Library","title":"SpineInterface.using_spinedb","text":"using_spinedb(url::String, mod=@__MODULE__; upgrade=false, filters=Dict(), extend=false)\n\nExtend module mod with convenience functions to access the contents of a Spine DB. The argument url is either the url of the DB, or of an HTTP Spine DB server associated with it.\n\nKeyword arguments\n\nupgrade: if true, then the database is upgraded to the latest revision.\nfilters: a Dict specifying filters.\nextend: if false, then any convenience functions already created in the given module are  overwritten. Otherwise they are extended.\n\nSee ObjectClass(), RelationshipClass(), and Parameter() for details on how to call the convenience functors.\n\n\n\n\n\n","category":"method"},{"location":"library/#SpineInterface.import_data-Tuple{String, Union{ObjectClass, RelationshipClass}, String}","page":"Library","title":"SpineInterface.import_data","text":"import_data(url, data, comment)\n\nImport data to a Spine db.\n\nArguments\n\nurl::String: the url of the target database. \ndata::Dict: the data to import, in the format below.\ncomment::String: the commit message.\n\nFormat of the data Dict:\n\nDict(\n    :object_classes => [:oc_name, ...],\n    :relationship_classes => [[:rc_name, [:oc_name1, :oc_name2, ...]], ...],\n    :objects => [[:oc_name, :obj_name], ...],\n    :relationships => [[:rc_name, [:obj_name1, :obj_name2, ...], ...],\n    :object_parameters => [[:oc_name, :param_name, default_value], ...],\n    :relationship_parameters => [[:rc_name, :param_name, default_value], ...],\n    :object_parameter_values => [[:oc_name, :obj_name, :param_name, value, :alt_name], ...],\n    :relationship_parameter_values => [[:rc_name, [:obj_name1, :obj_name2, ...], :param_name, value, :alt_name], ...],\n    :object_groups => [[:class_name, :group_name, :member_name], ...],\n    :scenarios => [(:scen_name, true), ...],  # true for the active flag, not in use at the moment\n    :alternatives => [:alt_name, ...],\n    :scenario_alternatives => [(:scen_name, :alt_name, nothing), (:scen_name, :lower_alt_name, :alt_name), ...]\n)\n\nExample\n\nd = Dict(\n    :object_classes => [:dog, :cat],\n    :objects => [[:dog, :brian], [:dog, :spike]]\n)\nimport_data(url, d, \"arf!\")\n\n\n\n\n\n","category":"method"},{"location":"library/#SpineInterface.ObjectClass-Tuple{}","page":"Library","title":"SpineInterface.ObjectClass","text":"(<oc>::ObjectClass)(;<keyword arguments>)\n\nAn Array of Object instances corresponding to the objects in class oc.\n\nArguments\n\nFor each parameter associated to oc in the database there is a keyword argument named after it. The purpose is to filter the result by specific values of that parameter.\n\nExamples\n\njulia> using SpineInterface;\n\n\njulia> url = \"sqlite:///\" * joinpath(dirname(pathof(SpineInterface)), \"..\", \"examples/data/example.sqlite\");\n\n\njulia> using_spinedb(url)\n\n\njulia> sort(node())\n5-element Array{Object,1}:\n Dublin\n Espoo\n Leuven\n Nimes\n Sthlm\n\njulia> commodity(state_of_matter=commodity(:gas))\n1-element Array{Object,1}:\n wind\n\n\n\n\n\n","category":"method"},{"location":"library/#SpineInterface.RelationshipClass-Tuple{}","page":"Library","title":"SpineInterface.RelationshipClass","text":"(<rc>::RelationshipClass)(;<keyword arguments>)\n\nAn Array of Object tuples corresponding to the relationships of class rc.\n\nArguments\n\nFor each object class in rc there is a keyword argument named after it. The purpose is to filter the result by an object or list of objects of that class, or to accept all objects of that class by specifying anything for this argument.\n_compact::Bool=true: whether or not filtered object classes should be removed from the resulting tuples.\n_default=[]: the default value to return in case no relationship passes the filter.\n\nExamples\n\njulia> using SpineInterface;\n\n\njulia> url = \"sqlite:///\" * joinpath(dirname(pathof(SpineInterface)), \"..\", \"examples/data/example.sqlite\");\n\n\njulia> using_spinedb(url)\n\n\njulia> sort(node__commodity())\n5-element Array{NamedTuple,1}:\n (node = Dublin, commodity = wind)\n (node = Espoo, commodity = wind)\n (node = Leuven, commodity = wind)\n (node = Nimes, commodity = water)\n (node = Sthlm, commodity = water)\n\njulia> node__commodity(commodity=commodity(:water))\n2-element Array{Object,1}:\n Nimes\n Sthlm\n\njulia> node__commodity(node=(node(:Dublin), node(:Espoo)))\n1-element Array{Object,1}:\n wind\n\njulia> sort(node__commodity(node=anything))\n2-element Array{Object,1}:\n water\n wind\n\njulia> sort(node__commodity(commodity=commodity(:water), _compact=false))\n2-element Array{NamedTuple,1}:\n (node = Nimes, commodity = water)\n (node = Sthlm, commodity = water)\n\njulia> node__commodity(commodity=commodity(:gas), _default=:nogas)\n:nogas\n\n\n\n\n\n","category":"method"},{"location":"library/#SpineInterface.Parameter-Tuple{}","page":"Library","title":"SpineInterface.Parameter","text":"(<p>::Parameter)(;<keyword arguments>)\n\nThe value of parameter p for a given arguments.\n\nArguments\n\nFor each object class associated with p there is a keyword argument named after it. The purpose is to retrieve the value of p for a specific object.\nFor each relationship class associated with p, there is a keyword argument named after each of the object classes involved in it. The purpose is to retrieve the value of p for a specific relationship.\ni::Int64: a specific index to retrieve in case of an array value (ignored otherwise).\nt::TimeSlice: a specific time-index to retrieve in case of a time-varying value (ignored otherwise).\ninds: indexes for navigating a Map (ignored otherwise). Tuples correspond to navigating nested Maps.\n_strict::Bool: whether to raise an error or return nothing if the parameter is not specified for the given arguments.\n\nExamples\n\njulia> using SpineInterface;\n\n\njulia> url = \"sqlite:///\" * joinpath(dirname(pathof(SpineInterface)), \"..\", \"examples/data/example.sqlite\");\n\n\njulia> using_spinedb(url)\n\n\njulia> tax_net_flow(node=node(:Sthlm), commodity=commodity(:water))\n4\n\njulia> demand(node=node(:Sthlm), i=1)\n21\n\n\n\n\n\n","category":"method"},{"location":"library/#SpineInterface.indices-Tuple{Parameter}","page":"Library","title":"SpineInterface.indices","text":"indices(p::Parameter, [c::Union{ObjectClass,RelationshipClass}]; kwargs...)\n\nAn iterator over all objects and relationships where the value of p is different than nothing.\n\nArguments\n\nFor each object class where p is defined, there is a keyword argument named after it; similarly, for each relationship class where p is defined, there is a keyword argument named after each object class in it. The purpose of these arguments is to filter the result by an object or list of objects of an specific class, or to accept all objects of that class by specifying anything for the corresponding argument.\n\nExamples\n\njulia> using SpineInterface;\n\n\njulia> url = \"sqlite:///\" * joinpath(dirname(pathof(SpineInterface)), \"..\", \"examples/data/example.sqlite\");\n\n\njulia> using_spinedb(url)\n\n\njulia> collect(indices(tax_net_flow))\n1-element Array{NamedTuple{(:commodity, :node),Tuple{Object,Object}},1}:\n (commodity = water, node = Sthlm)\n\njulia> collect(indices(demand))\n5-element Array{Object,1}:\n Nimes\n Sthlm\n Leuven\n Espoo\n Dublin\n\n\n\n\n\n","category":"method"},{"location":"library/#SpineInterface.TimeSlice-Tuple{DateTime, DateTime}","page":"Library","title":"SpineInterface.TimeSlice","text":"TimeSlice(start::DateTime, end_::DateTime)\n\nConstruct a TimeSlice with bounds given by start and end_.\n\n\n\n\n\n","category":"method"},{"location":"library/#SpineInterface.duration-Tuple{TimeSlice}","page":"Library","title":"SpineInterface.duration","text":"duration(t::TimeSlice)\n\nThe duration of time slice t as a multiple of the duration unit.\n\n\n\n\n\n","category":"method"},{"location":"library/#SpineInterface.before-Tuple{TimeSlice, TimeSlice}","page":"Library","title":"SpineInterface.before","text":"before(a::TimeSlice, b::TimeSlice)\n\nDetermine whether the end point of a is exactly the start point of b.\n\n\n\n\n\n","category":"method"},{"location":"library/#SpineInterface.iscontained-Tuple{TimeSlice, TimeSlice}","page":"Library","title":"SpineInterface.iscontained","text":"iscontained(b, a)\n\nDetermine whether b is contained in a.\n\n\n\n\n\n","category":"method"},{"location":"library/#SpineInterface.overlaps-Tuple{TimeSlice, TimeSlice}","page":"Library","title":"SpineInterface.overlaps","text":"overlaps(a, b)\n\nDetermine whether a and b overlap.\n\n\n\n\n\n","category":"method"},{"location":"library/#SpineInterface.overlap_duration-Tuple{TimeSlice, TimeSlice}","page":"Library","title":"SpineInterface.overlap_duration","text":"overlap_duration(a::TimeSlice, b::TimeSlice)\n\nThe duration of the period where a and b overlap.\n\n\n\n\n\n","category":"method"},{"location":"library/#SpineInterface.t_lowest_resolution-Tuple{Vector{TimeSlice}}","page":"Library","title":"SpineInterface.t_lowest_resolution","text":"t_lowest_resolution(t_iter)\n\nReturn an Array containing only time slices from t_iter that aren't contained in any other.\n\n\n\n\n\n","category":"method"},{"location":"library/#SpineInterface.t_highest_resolution-Tuple{Vector{TimeSlice}}","page":"Library","title":"SpineInterface.t_highest_resolution","text":"t_highest_resolution(t_iter)\n\nReturn an Array containing only time slices from t_iter that do not contain any other.\n\n\n\n\n\n","category":"method"},{"location":"library/#SpineInterface.write_parameters-Tuple{Dict, String}","page":"Library","title":"SpineInterface.write_parameters","text":"write_parameters(parameters, url::String; <keyword arguments>)\n\nWrite parameters to the Spine database at the given RFC-1738 url. parameters is a dictionary mapping parameter names to another dictionary mapping object or relationship (NamedTuple) to values.\n\nArguments\n\nparameters::Dict: a dictionary mapping parameter names, to entities, to parameter values\nupgrade::Bool=true: whether or not the database at url should be upgraded to the latest revision.\nfor_object::Bool=true: whether to write an object parameter or a 1D relationship parameter in case the number of dimensions is 1.\nreport::String=\"\": the name of a report object that will be added as an extra dimension to the written parameters.\nalternative::String: an alternative where to write the parameter values.\ncomment::String=\"\": a comment explaining the nature of the writing operation.\n\n\n\n\n\n","category":"method"},{"location":"library/#Constants","page":"Library","title":"Constants","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"anything","category":"page"},{"location":"library/#SpineInterface.anything","page":"Library","title":"SpineInterface.anything","text":"anything\n\nThe singleton instance of type Anything, used to specify all-pass filters in calls to RelationshipClass().\n\n\n\n\n\n","category":"constant"},{"location":"tutorials/tutorial_spineopt_database/#Tutorial-SpineOpt-database","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"","category":"section"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"The optimization model SpineOpt uses SpineOpt databases as its input. A SpineOpt database is a specific form of the spine database. In other words a SpineOpt database is a spine database but a spine database is not necessarily a SpineOpt database.","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"For this tutorial we will be using an existing database which can be found in the examples folder.","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"using SpineInterface\n\nurl=\"sqlite:///$(@__DIR__)/example_spineopt_database.sqlite\"\nusing_spinedb(url)","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"note: Note\nThe database file and the database that is loaded into Julia are not automatically synced. If you make changes through Julia, you need to save your changes with the import_data function. Similarly, if you made some changes in the database with the Spine Toolbox db editor, you need to reload the database into Julia.","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"The convenience functions that are generated by using_spinedb are now specific to the SpineOpt structure (units, nodes, connections, ...).","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"With these convenience functions we can navigate the database:","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"node() provides a list of the nodes\nunit__to_node() provides a list of all the units that have flows to the node\nunit__from_node() provides a list of all the units that have flows from the node\n...","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"note: Note\n__ is used as a name convention, e.g. dimension __ name","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"node()\n\n    2-element Vector{Union{Int64, Object, TimeSlice}}:\n        elec_finland\n        elec_netherlands","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"From the nodes it seems that we are dealing with the electricity system in two countries. Let's see if these nodes are supplied by power plants. We do that by looking at all the relationships between the nodes and possible units connected to those nodes.","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"unit__to_node()\n\n    3-element Vector{NamedTuple{K, V} where {K, V<:Tuple{Vararg{Union{Int64, Object, TimeSlice}}}}}:\n        (unit = ccgt, node = elec_netherlands)\n        (unit = pvfarm, node = elec_netherlands)\n        (unit = windfarm, node = elec_finland)","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"Ok, that is great. But perhaps we do not want to query all possible power plants at the same time. We can pass some options to the query.","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"All the relationship classes accept three options:","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"no argument: you get all information, e.g. unit__to_node() gives a tuple of all the units and to which node they provide flow.\nunit argument: information based on units, e.g. unit__to_node(unit=unit(:ccgt)) gives all nodes where unit ccgt provides flow to\nnode argument: information based on nodes, e.g. unit__tonode(node=node(:elecfinland)) gives all units that provide flow to the finland node","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"@show unit__to_node()\n@show unit__to_node(unit=unit(:ccgt))\n@show unit__to_node(node=node(:elec_finland))\n\n    unit__to_node() = NamedTuple{K, V} where {K, V<:Tuple{Vararg{Union{Int64, Object, TimeSlice}}}}[(unit = ccgt, node = elec_netherlands), (unit = pvfarm, node = elec_netherlands), (unit = windfarm, node = elec_finland)]\n    unit__to_node(unit = unit(:ccgt)) = Object[elec_netherlands]\n    unit__to_node(node = node(:elec_finland)) = Object[windfarm]","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"We can access the node or unit information by calling them by their name as we did before but it is actually more common to use an iterator.","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"for u in unit()\n    @show u\nend\n\n    u = ccgt\n    u = pvfarm\n    u = windfarm","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"for n in node()\n    @show n,unit__to_node(node=n)\nend\n\n    (n, unit__to_node(node = n)) = (elec_finland, Object[windfarm])\n    (n, unit__to_node(node = n)) = (elec_netherlands, Object[ccgt, pvfarm])","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"for n in node()\n    @show n,connection__from_node(node=n)\nend\n\n    (n, connection__from_node(node = n)) = (elec_finland, Any[])\n    (n, connection__from_node(node = n)) = (elec_netherlands, Object[interconnector])","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"for conn in connection()\n    @show conn, connection__from_node(connection=conn)\nend\n\n    (conn, connection__from_node(connection = conn)) = (interconnector, Object[elec_netherlands])","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"These Objects and Relationships can have parameters associated to them. The easiest structure for a parameter is a direct value (e.g. 100). The most complex structure for a parameter is a Map. These parameters can be accessed from SpineInterface. Take for example the demand.","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"for n in node()\n    @show n, demand(node=n)\nend\n\n    (n, demand(node = n)) = (elec_finland, Map{Dates.DateTime, Map{Symbol, TimeSeries{Float64}}}([Dates.DateTime(\"2000-01-01T00:00:00\"), Dates.DateTime(\"2000-01-01T12:00:00\")], Map{Symbol, TimeSeries{Float64}}[Map{Symbol, TimeSeries{Float64}}([:scen1, :scen2], TimeSeries{Float64}[TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[150.0,200.0](false,false), TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[180.0,200.0](false,false)], Dict{Symbol, TimeSeries{Float64}}(:scen1 => TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[150.0,200.0](false,false), :scen2 => TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[180.0,200.0](false,false))), Map{Symbol, TimeSeries{Float64}}([:scen1, :scen2], TimeSeries{Float64}[TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[150.0,200.0](false,false), TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[200.0,220.0](false,false)], Dict{Symbol, TimeSeries{Float64}}(:scen1 => TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[150.0,200.0](false,false), :scen2 => TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[200.0,220.0](false,false)))], Dict{Dates.DateTime, Map{Symbol, TimeSeries{Float64}}}(Dates.DateTime(\"2000-01-01T12:00:00\") => Map{Symbol, TimeSeries{Float64}}([:scen1, :scen2], TimeSeries{Float64}[TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[150.0,200.0](false,false), TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[200.0,220.0](false,false)], Dict{Symbol, TimeSeries{Float64}}(:scen1 => TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[150.0,200.0](false,false), :scen2 => TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[200.0,220.0](false,false))), Dates.DateTime(\"2000-01-01T00:00:00\") => Map{Symbol, TimeSeries{Float64}}([:scen1, :scen2], TimeSeries{Float64}[TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[150.0,200.0](false,false), TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[180.0,200.0](false,false)], Dict{Symbol, TimeSeries{Float64}}(:scen1 => TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[150.0,200.0](false,false), :scen2 => TimeSeries{2000-01-01T00:00:00~>2000-01-01T01:00:00}[180.0,200.0](false,false))))))\n    (n, demand(node = n)) = (elec_netherlands, 100)","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"Some of the data will be linked to a variable and as such you will need to specify the indices of that variable.","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"The indices can consist of","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"nodes\nscenarios\ntime","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"The indices can be accessed from SpineInterface as well.","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"indices(demand)\ncollect(indices(demand)) # makes it more readable\n\n    2-element Vector{Object}:\n        elec_finland\n        elec_netherlands","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"For the time you can use the Dates package.","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"using Dates\ndemand(\n    node=node(:elec_finland),\n    t0=DateTime(2000, 1, 1, 12),\n    s=stochastic_scenario(:scen2),\n    t=DateTime(2000, 1, 1, 1)\n)\n# The time seems to go backwards but that is because the time in the database has accidentally been set backwards.\n\n    220.0","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"So far we have only taken a look at the existing data but we can also write new data to the database. Let's add a capacity to the pvfarm.","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"import_data(\n    url,\n    \"load capacity value\";\n    relationship_parameters=[[\"unit__to_node\",\"unit_capacity\"]],\n    relationship_parameter_values=[[\"unit__to_node\", [\"pvfarm\", \"elec_netherlands\"], \"unit_capacity\", 40]],\n)","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"note: Note\nParameter values always have an alternative name. Alternative names are used for building scenarios in the SpineOpt model. By default any data added through a script gets a timestamp as an alternative name. However, the alternative name can also be specified.import_data(\n    url,\n    \"load capacity value\";\n    relationship_parameters=[[\"unit__to_node\",\"unit_capacity\"]],\n    relationship_parameter_values=[[\"unit__to_node\", [\"pvfarm\", \"elec_netherlands\"], \"unit_capacity\", 40, \"alt\"]],\n    alternatives=[\"alt\"]\t\n)","category":"page"},{"location":"tutorials/tutorial_spineopt_database/","page":"Tutorial SpineOpt database","title":"Tutorial SpineOpt database","text":"The full script can be found in the examples folder. The script also includes some example code for how these convenience functions can be used in a more complex function, e.g. to find all the isolated nodes (i.e. nodes without relationships).","category":"page"},{"location":"#SpineInterface.jl","page":"Home","title":"SpineInterface.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides the ability to access the contents of a Spine database in a way that's convenient for writing algorithms. The functions import_data and using_spinedb are the main stars of the package: Given the url of a Spine database, import_data can write data to the (new) database and using_spinedb creates a series of convenience functions to retrieve the contents of that database  in the Julia module or session where it's called. In this way, with import_data you can populate a Spine database with that data for a system you want to study, call using_spinedb in your module to generate the convenience functions, and then use those functions to build, e.g., an optimisation model for that system. This allows you to develop fully data-driven applications. One key example is the SpineOpt package, which uses the above technique to generate and run energy system integration models.","category":"page"},{"location":"#Compatibility","page":"Home","title":"Compatibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package requires Julia 1.6 or later.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can install SpineInterface from the SpineJuliaRegistry as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\npkg\"registry add https://github.com/Spine-tools/SpineJuliaRegistry\"\npkg\"add SpineInterface\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"However, for keeping up with the latest developments, it is highly recommended to install directly from the source. This can be done by downloading the repository on your computer, and then installing the module locally with","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.develop(\"<PATH_TO_SPINEINTERFACE>\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"where <PATH_TO_SPINEINTERFACE> is the path to the root folder of the SpineInterface repository on your computer (the one containing the Project.toml file).","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nSpineInterface has been primarily designed to work through Spine Toolbox, and shouldn't require specific setup when being called from Spine Toolbox workflows.When running SpineInterface outside Spine Toolbox (e.g. from a Julia script directly), however, SpineInterface relies on the Spine Database API Python package, which is accessed using the PyCall.jl module. Thus, one needs to configure PyCall.jl to use a Python executable with Spine Database API installed, which can be done according to the PyCall readme. If you're using Conda environments for Python, the .configure_pycall_in_conda.jl script can be used to automatically configure PyCall to use the Python executable of that Conda environment.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Essentially, SpineInterface works just like any Julia module","category":"page"},{"location":"","page":"Home","title":"Home","text":"using SpineInterface\n\nurl = \"sqlite:///quick_start.sqlite\"\ncommitmessage = \"initial commit\"\n\nimport_data(url,commitmessage;\n\tobject_classes=[\"colors\", \"shapes\"],\n\tobjects = [\n\t\t[\"colors\", \"red\"], \n\t\t[\"colors\", \"blue\"], \n\t\t[\"shapes\", \"square\"], \n\t\t[\"shapes\", \"circle\"]\n\t]\n)\n\nusing_spinedb(url)\n\ncolors()#returns all colors\nshapes(\"square\")#returns the square","category":"page"},{"location":"","page":"Home","title":"Home","text":"with import_data and using_spinedb being the key functions for interfacing a Spine Datastore. import_data is used to create a new Spine Datastore or write data to an existing Spine Datastore. using_spinedb creates the convenience functions to access the data in the Spine Datastore.","category":"page"},{"location":"#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To get started with SpineInterface you can take a look at the tutorials:","category":"page"},{"location":"","page":"Home","title":"Home","text":"'Tutorial spine database' shows the basic functionality of SpineInterface for general spine databases\n'Tutorial SpineOpt database' shows the more specific functionality for SpineOpt databases","category":"page"},{"location":"","page":"Home","title":"Home","text":"The files corresponding to these tutorials can be found in the examples folder of the github repository SpineInterface.","category":"page"},{"location":"#Library-outline","page":"Home","title":"Library outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"library.md\"]\nDepth = 3","category":"page"}]
}
